---
title: Software
layout: page

lang:
# All react packages has social stats.
  react:
    - react-clipboard-icon
    - react-intl-inject
    - trunx
    - zeroconf-redux
    - SVGx
  bash:
    - bb-clone
    - dir
    - gh-clone
    - home
    - dotsoftware
    - yyyymmdd
  golang:
    - m2c
    - primes
    - s2
  perl:
    - App-cloc-pm
    - Task-BeLike-FIBO-pm
    - Sweet-Home-pm
    - netvision
  docker:
    - fake-aws-redshift
  nodejs:
    packages_with_social_stats:
      - algebra
      - dflow
      - flow-view
      - games-of-life
      - iper
    packages_not_in_the_registry:
      - npm-config
      - redux-todoapp
    tiny_packages:
      - algebra-group
      - algebra-cyclic
      - algebra-ring
      - aws-lambda-res
      - bitstamp-kiss
      - cayley-dickson
      - country-isocode2
# TODO: Consider create another category for client side packages.
      - dextop
      - dot-editorconfig
      - fa-svg-icon
      - flow-chart
      - geohash-neighbours
      - https-scheme
      - i-am-not-a-robot
      - indices-permutations
      - inlined
      - laplace-determinant
      - load-html
      - mdconf-from
      - mobius-transformation
      - matrix-multiplication
      - markdown2code
      - multidim-array-index
      - numerology
      - not-defined
      - npm-start-command
      - OLAP-cube
# TODO: next one is not a package actually, it is a new category.
      - os-icons8
      - pdsp
      - prime-number
      - read-file-utf8
      - regex-weburl
      - standa
      - static-props
      - strict-mode
      - SQL-tokenizer
      - SQL92-JSON
      - SQL92-keywords
      - SQL92-operators
      - tensor-contraction
      - tensor-product
      - three-orbitcontrols
      - trend-steps
      - tris3d
      - tris3d-ai
      - tris3d-canvas
      - volatility
      - write-file-utf8
      - x3dom-livereload
      - y-combinator
---

{% assign repo = site.data.github.repos %}

<link rel="stylesheet" href="style.css">

<div class="horyzontal-scroll">
  {% for lang in page.lang %}
    <img
      onclick="document.getElementById('{{ lang[0] }}').scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' })"
      src="/svg/logos/{{ lang[0] }}.svg"
      alt="{{ lang[0] }}"
    />
  {% endfor %}
</div>

<section id="nodejs" class="paper">
  <p>
    <img
      alt="NodeJS logo"
      class="software-logo"
      src="/svg/logos/nodejs.svg"
    />

    My first experiment with NodeJS was on August 2012: I wrote a prototype of a multiplayer game with Socket.io and I was amazed by its power and simplicity. Also, npm was a step forward at that time in the world of package management. Nowadays I still appreciate this concept: using one language for backend and frontend. Few years later there was a quantum leap in the JavaScript ecosystem, the language evolved and the transition was handled in the best way (IMO). In general, I consider JavaScript the <em>lingua franca</em> of IT: if I write an algorithm in JavaScript almost any developer can read it and translate it in any other language.
  </p>

  <ul class="tile-list">
    {% for pkg in page.lang.nodejs.packages_with_social_stats %}
      <li>
        <a href="{{ repo[pkg].homepage }}">
          <h3>{{ pkg }}</h3>

          <blockquote><p>{{ repo[pkg].description }}</p></blockquote>
        </a>

        {% include repo_social_badges.html repo=pkg %}
      </li>
    {% endfor %}
  </ul>
</section>

<section id="react" class="paper">
  <p>
    <img
      alt="React logo"
      class="software-logo"
      src="/svg/logos/react.svg"
    />
    I started using React in early 2016, when I discovered Redux and I thought: this is the right way to do it.
  </p>

  <ul class="tile-list">
    {% for react_pkg in page.lang.react %}
      <li>
        <a href="{{ repo[react_pkg].homepage }}">
          <h3>{{ react_pkg }}</h3>

          <blockquote><p>{{ repo[react_pkg].description }}</p></blockquote>
        </a>

        {% include repo_social_badges.html repo=react_pkg %}
      </li>
    {% endfor %}
  </ul>
</section>

<section class="paper">
  <div class="left-top">
    <img
      alt="npm logo"
      class="software-logo"
      src="/svg/logos/npm-2.svg"
    />
  </div>
  <p>
    I wrote some NodeJS <strong>micro</strong> packages.
  </p>

  <dl>
    {% for tiny_pkg in page.lang.nodejs.tiny_packages %}
      <dt>
        <a href="{{ repo[tiny_pkg].homepage }}">{{ tiny_pkg }}</a>
      </dt>
      <dd>{{ repo[tiny_pkg].description }}</dd>
    {% endfor %}
  </dl>

  <p>The following packages are not in the npm registry.</p>

  <dl>
    {% for private_pkg in page.lang.nodejs.packages_not_in_the_registry %}
      <dt>
        <a href="{{ repo[private_pkg].homepage }}">{{ private_pkg }}</a>
      </dt>
      <dd>{{ repo[private_pkg].description }}</dd>
    {% endfor %}
  </dl>
</section>

<section id="docker" class="paper">
  <p>
    <img
      alt="Docker logo"
      class="software-logo"
      src="/svg/logos/docker.svg"
    />

    I like the concept of reproducibility: I did few experiments with Docker. It is a great tool, but sincerely I still use more Amazon AMIs.
  </p>

  <dl>
    {% for docker_image in page.lang.docker %}
      <dt>
        <a href="{{ repo[docker_image].homepage }}">{{ docker_image }}</a>
      </dt>
      <dd>{{ repo[docker_image].description }}</dd>
    {% endfor %}
  </dl>
</section>

<section id="bash" class="paper">
  <p>
    <img
      alt="Bash logo"
      class="software-logo"
      src="/svg/logos/bash.svg"
    />
    I am addicted to CLIs and the shell. I wrote few tools and my opinion is that a bash script is still the cheapest and fastest way to automate a task.
  </p>

  <dl>
    {% for bash_project in page.lang.bash %}
      <dt>
        <a href="{{ repo[bash_project].homepage }}">{{ bash_project }}</a>
      </dt>
      <dd>{{ repo[bash_project].description }}</dd>
    {% endfor %}

    <dt>
      <a href="{{ repo['kiss-literate-programming'].homepage }}">
        <img src="https://img.shields.io/badge/kiss-literate-orange.svg" alt="KLP">
      </a>
    </dt>
    <dd>{{ repo['kiss-literate-programming'].description }}</dd>
  </dl>
</section>

<section id="golang" class="paper">
  <p>
    <img
      alt="Golang logo"
      class="software-logo"
      src="/svg/logos/golang.svg"
    />

    Probably Golang is not the definitive language, but, for me is perfect. First of all, a compiled language was missing in my reportoire. Deploying or distribute a single executable is a big win. I also like the simplicity of the language: yes, only 25 keywords actually attract me. I really like the fact that it handles concurrency and it is multicore out of the box: it relaxes me, I can focus only on the algorithm... but I confess that, as a mathematician, I felt in love with Golang cause it has builtin complex number data type. Wow!
  </p>

  <dl>
    {% for golang_project in page.lang.golang %}
    <dt>
      <a href="{{ repo[golang_project].homepage }}">{{ golang_project }}</a>
    </dt>
    <dd>{{ repo[golang_project].description }}</dd>
    {% endfor %}
  </dl>
</section>

<section id="perl" class="paper">
  <p>
    <img
      alt="Perl logo"
      class="software-logo"
      src="/svg/logos/perl.svg"
    />

    When I started working in IT in 2005 my boss said: you need to learn Perl. Big respect for the camel, I learned a lot from this language and its community. It is still my preferred language for string manipulation and parsing.
  </p>

  <dl>
    {% for perl_project in page.lang.perl %}
    <dt>
      <a href="{{ repo[perl_project].homepage }}">{{ perl_project }}</a>
    </dt>
    <dd>{{ repo[perl_project].description }}</dd>
    {% endfor %}
  </dl>
</section>
